<!doctype html><html lang=ru><head><meta charset=utf-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1" name=viewport><title>7 способов получения значения из Vec<_> в Rust</title><meta content="Кодерный понедельник" name=description><meta content=https://freecx.github.io/touch-icon.png property=og:image><link href=https://code.cdn.mozilla.net/fonts/fira.css rel=stylesheet><link href=https://freecx.github.io/favicon.png rel=icon><link href=https://freecx.github.io/touch-icon.png rel=apple-touch-icon><link href=https://freecx.github.io/main.css rel=stylesheet><link href=https://freecx.github.io/syntax.css rel=stylesheet><body><aside class=logo><a href=https://github.com/FreeCX> <img class=gravatar src=https://freecx.github.io/avatar.png> </a><span class=logo-prompt>Я на github</span></aside><article><div class=center><h1>7 способов получения значения из Vec<_> в Rust</h1><time>4 February 2016</time></div><div class=divider></div><p>На протяжении нескольких дней мне всё время не давал покоя вопрос: каким способом лучше всего вывести данные <strong>n</strong>-того элемента? Допустим у нас есть вектор некоторых значений (<em>u32</em> или <em>i32</em>) и мы хотим вывести на печать второй элемент.<pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span style=color:#8959a8>fn </span><span style=color:#4271ae>main</span><span>() {
</span><span>    </span><span style=color:#8959a8>let</span><span> a </span><span style=color:#3e999f>= </span><span>vec![</span><span style=color:#f07219>1</span><span>, </span><span style=color:#f07219>2</span><span>, </span><span style=color:#f07219>3</span><span>, </span><span style=color:#f07219>42</span><span>, </span><span style=color:#f07219>7</span><span>];
</span><span>    </span><span style=color:#8959a8>let</span><span> n </span><span style=color:#3e999f>= </span><span style=color:#f07219>2</span><span>;
</span><span>    println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, </span><span style=color:#8e908c>/* insert here */</span><span>);
</span><span>}
</span></code></pre><h3 id=realizatsii>Реализации</h3><p><a href=http://is.gd/WE69jq><em>Очевидный</em></a> вариантом является явное обращение по индексу к элементу<pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span>println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, a[n]);
</span></code></pre><p>Но сколько есть способов получить элемент из списка и в чём различия между ними?<p>Хорошим тоном было бы использование функции <em>get</em>. В случае если индекс выходит за пределы нашего вектора мы могли бы обработать данную ситуацию и сообщить об ошибке.<p>В данном <a href=http://is.gd/c8OnJD>случае</a> я использовал <em>unwrap</em> как более простой способ распаковки полученного значения (как и в последующих), который в случае ошибки корректно (но с паникой) завершит программу и выведет подробности о проблеме.<pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span>println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, a.</span><span style=color:#4271ae>get</span><span>(n).</span><span style=color:#4271ae>unwrap</span><span>());
</span></code></pre><p><a href=http://is.gd/ySZQDF>Ещё одним</a> способом получения <strong>n</strong>-того элемента из вектора является использование <em>итератора</em> и метода <a href=https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.nth><em>nth</em></a><pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span>println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, a.</span><span style=color:#4271ae>iter</span><span>().</span><span style=color:#4271ae>nth</span><span>(n).</span><span style=color:#4271ae>unwrap</span><span>());
</span></code></pre><p>как и <a href=http://is.gd/4ojyBS>композиция методов</a> <a href=https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.skip><em>skip</em></a> и <a href=https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#tymethod.next><em>next</em></a><pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span>println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, a.</span><span style=color:#4271ae>iter</span><span>().</span><span style=color:#4271ae>skip</span><span>(n).</span><span style=color:#4271ae>next</span><span>().</span><span style=color:#4271ae>unwrap</span><span>());
</span></code></pre><p>Так же можно обратится к трейту <a href=https://doc.rust-lang.org/stable/std/ops/trait.Index.html><em>Index</em></a> и <a href=http://is.gd/cdK0Kk>использовать его</a> для доступа к значению<pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span style=color:#8959a8>use </span><span>std::ops::Index;
</span><span style=color:#8e908c>// ...
</span><span>println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, a.</span><span style=color:#4271ae>index</span><span>(n));
</span></code></pre><p>Ну и под конец самое интересное — использование <strong>unsafe</strong> методов.<p>Тут у нас не очень большой выбор: использовать метод <em>get_unchecked</em> или прямое обращение к указателю, ну или почти прямое :).<p>Использование <a href=http://is.gd/1zI5D1><em>get_unchecked</em></a> выглядит следующим образом<pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span style=color:#8959a8>unsafe </span><span>{
</span><span>    println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, a.</span><span style=color:#4271ae>get_unchecked</span><span>(n));
</span><span>}
</span></code></pre><p>И <a href=http://is.gd/SUpQCP>обращение к указателю</a>, где нужно использовать разыменование<pre class=language-rust data-lang=rust style=color:#111;background-color:#f9f9f9><code class=language-rust data-lang=rust><span style=color:#8959a8>unsafe </span><span>{
</span><span>    println!(</span><span style=color:#839c00>"a[</span><span>{}</span><span style=color:#839c00>] = </span><span>{}</span><span style=color:#839c00>"</span><span>, n, </span><span style=color:#3e999f>*</span><span>(a.</span><span style=color:#4271ae>as_ptr</span><span>().</span><span style=color:#4271ae>offset</span><span>(n)));
</span><span>}
</span></code></pre><h3 id=sravnenie-i-rezul-taty>Сравнение и результаты</h3><p>Закончив с кодом перейдём к сравнению данных методов. Для этого используем несколько видов компиляции и будем сравнивать по размеру выходного файла<ul><li>default: <code>$ rustc</code><li>release: <code>$ rustc -O -C debuginfo=0</code><li>release+lto: <code>$ rustc -O -C debuginfo=0 -C lto</code><li>release+dynamic: <code>$ rustc -O -C debuginfo=0 -C prefer-dynamic</code></ul><table><thead><tr><th>Метод\Оптимизация<th>default<th>release<th>release+lto<th>release+dynamic<tbody><tr><td>[n]<td>581 552<td>572 768<td>543 688<td>10 184<tr><td>get(n)<td>+248<td>+72<td>+80<td>+72<tr><td>iter().nth(n)<td>+5216<td>+72<td>+80<td>+72<tr><td>iter().skip(n).next()<td>+5456<td>+72<td>+80<td>+80<tr><td>index(n)<td>+80<td>+72<td>+80<td>+80<tr><td>get_unchecked(n)<td>+168<td>+72<td>+80<td>+72<tr><td>as_ptr().offset(n)<td>+56<td>0<td>0<td>0</table><p>Лучшие результаты показали два метода (если не считать компиляцию без оптимизации) — [n] и as_ptr().offset(n), оно и очевидно в следствии прямого доступ к переменной.<p>Метод основанный на <em>index(n)</em> показал стабильный результат в не зависимости от оптимизации кода. Остальные имеют стабильный размер при оптимизации, что приводит к мысли — они все преобразуются к одному виду.<p>Делаю из всего этого вывод: используйте соответствующим метод под конкретную задачу, но всё-таки прямое обращение по индексу наиболее экономное :)<h3 id=poleznye-ssylki>Полезные ссылки</h3><p>[1] <a href=https://doc.rust-lang.org/stable/std/>The Rust Standard Library</a><p>[2] The Rust Programming Language: <a href=https://doc.rust-lang.org/book/>eng</a>, <a href=https://rurust.github.io/rust_book_ru/index.html>rus</a><p>[3] <a href=https://play.rust-lang.org/>Rust Playground</a></article><div class=back><a href=https://freecx.github.io/>Назад</a></div><div class=footer><span>Также читайте <a title="ты сам сломал ссылку, так что ничего личного" href=https://antoniii.github.io/> <s>antoniii</s> </a> <a href=https://citrux.github.io/>citrux</a> <a href=https://sputnikas.github.io/>sputnikas</a> </span></div><script>let msg=` А спонсор статей в моём блоге -- моя лень -- спонсор статей.`;[`=`.repeat(msg.length+ 1),msg,`=`.repeat(msg.length+ 1)].forEach(a=>console.warn(a))</script>