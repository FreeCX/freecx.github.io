---
title: 7 способов получения значения из Vec<_> в Rust
layout: post
---

На протяжении нескольких дней мне всё время не давал покоя вопрос: каким способом лучше всего 
вывести данные **n**-того элемента? Допустим у нас есть вектор некоторых значений (*u32* или *i32*) 
и мы хотим вывести на печать второй элемент. 

```rust
fn main() {
    let a = vec![1, 2, 3, 42, 7];
    let n = 2;
    println!("a[{}] = {}", n, /* insert here */);
}
```

### Реализации

[*Очевидный*](http://is.gd/WE69jq) вариантом является явное обращение по индексу к

```rust
println!("a[{}] = {}", n, a[n]);
```

Но сколько есть способов получить элемент из списка и в чём различия между ними?

Хорошим тоном было бы использование функции *get*. В случае если индекс выходит за пределы 
нашего векторы мы могли бы обработать данную ситуацию и сообщить об ошибке.

В данном [случае](http://is.gd/c8OnJD) я использовал *unwrap* как более простой способ распаковки 
полученного значения (как и в последующих), который в случае ошибки корректно завершит программу 
и выведет подробности о проблеме.

```rust
println!("a[{}] = {}", n, a.get(n).unwrap());
```

[Ещё одним](http://is.gd/ySZQDF) способом получения **n**-того элемента из вектора является 
использование *итератора* и метода
[*nth*](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.nth) 

```rust
println!("a[{}] = {}", n, a.iter().nth(n).unwrap());
```

как и [композиция методов](http://is.gd/4ojyBS)
[*skip*](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.skip) и 
[*next*](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#tymethod.next) 

```rust
println!("a[{}] = {}", n, a.iter().skip(n).next().unwrap());
```

Так же можно обратится к трейту [*Index*](https://doc.rust-lang.org/stable/std/ops/trait.Index.html)
и [использовать его](http://is.gd/cdK0Kk) для доступа к значению

```rust
use std::ops::Index;
// ...
println!("a[{}] = {}", n, a.index(n));
```

Ну и под конец самое интересное -- использование **unsafe** методов.

Тут у нас не очень большой выбор: использовать метод *get_unchecked* и прямое обращение к 
указателю, ну или почти прямое :).

Использование [*get_unchecked*](http://is.gd/1zI5D1) выглядит следующим образом

```rust
unsafe {
    println!("a[{}] = {}", n, a.get_unchecked(n));
}
```

И [обращение к указателю](http://is.gd/SUpQCP), где нужно использовать разыменование указателя

```rust
unsafe {
    println!("a[{}] = {}", n, *(a.as_ptr().offset(n)));
}
```

### Сравнение и результаты

Для сравнения данных методов используем несколько видов компиляции и будем сравнивать по размеру 
выходного файла

  * default: `$ rustc`
  * release: `$ rustc -O -C debuginfo=0`
  * release+lto: `$ rustc -O -C debuginfo=0 -C lto`
  * release+dynamic: `$ rustc -O -C debuginfo=0 -C prefer-dynamic`

| Метод\Оптимизация     | default | release | release+lto | release+dynamic |
|-----------------------|---------|---------|-------------|-----------------|
| [n]                   | 581 552 | 572 768 | 543 688     | 10 184          |
| get(n)                | +248    | +72     | +80         | +72             |
| iter().nth(n)         | +5216   | +72     | +80         | +72             |
| iter().skip(n).next() | +5456   | +72     | +80         | +80             |
| index(n)              | +80     | +72     | +80         | +80             |
| get_unchecked(n)      | +168    | +72     | +80         | +72             |
| as_ptr().offset(n)    | +56     | 0       | 0           | 0               |

Лучшие результаты показали два метода (если не считать компиляцию без оптимизации) -- [n] и 
as_ptr().offset(n), оно и очевидно в следствии прямого доступ к переменной.

Метод основанный на *index(n)* показал стабильный результат в не зависимости от оптимизации кода.
Остальные имеют стабильный размер при оптимизации, что приводит к мысли -- они все преобразуются к 
одному виду.

Делаю из всего этого вывод: используйте соответствующим метод под конкретную задачу, но всё-таки 
прямое обращение по индексу наиболее экономное :)

### Полезные ссылки
[1] [The Rust Standard Library](https://doc.rust-lang.org/stable/std/)

[2] The Rust Programming Language: [eng](https://doc.rust-lang.org/book/), 
[rus](https://rurust.github.io/rust_book_ru/index.html)

[3] [Rust Playground](https://play.rust-lang.org/)
